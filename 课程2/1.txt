function speedChange_callback(ui,id,newVal)
    speed=minMaxSpeed[1]+(minMaxSpeed[2]-minMaxSpeed[1])*newVal/100
end

function sysCall_init()
-- This is executed exactly once, the first time this script is executed
    bubbleRobBase=sim.getObjectAssociatedWithScript(sim.handle_self) -- this is bubbleRob's handle
    leftMotor=sim.getObjectHandle("BubbleRob_leftMotor_zjw") -- Handle of the left motor
    rightMotor=sim.getObjectHandle("BubbleRob_rightMotor_zjw") -- Handle of the right motor
    noseSensor=sim.getObjectHandle("BubbleRob_sensingNose_zjw") -- Handle of the proximity sensor
    minMaxSpeed={50*math.pi/180,300*math.pi/180} -- Min and max speeds for each motor
    turnUntilTime1=-1 -- Tells whether bubbleRob is in forward or backward mode
    turnUntilTime2=-1
    turnUntilTime3=-1
    robotCollection=sim.createCollection(0)
    sim.addItemToCollection(robotCollection,sim.handle_tree,bubbleRobBase,0)
    all_objects = sim.getCollectionObjects(robotCollection)
    for id, object in ipairs(all_objects) do print(sim.getObjectName(object)) end
    
    distanceSegment=sim.addDrawingObject(sim.drawing_lines,4,0,-1,1,{0,1,0})
    robotTrace=sim.addDrawingObject(sim.drawing_linestrip+sim.drawing_cyclic,2,0,-1,200,{1,1,0},nil,nil,{1,1,0})
    graph=sim.getObjectHandle('BubbleRob_Graph_zjw')
    distStream=sim.addGraphStream(graph,'bubbleRob clearance','m',0,{1,0,0})

    speed=(minMaxSpeed[1]+minMaxSpeed[2])*0.3
    
   
    -- do some initialization here
end

function sysCall_actuation()
    result=sim.readProximitySensor(noseSensor) -- Read the proximity sensor
    -- If we detected something, we set the backward mode:
    if (result>0) then 
       turnR = 0.2
        turnLength = turnR * 2 * math.pi / 4        
        wheel_v_speed = speed * 0.08
        turn90degreeTime = turnLength/wheel_v_speed * 1.2
        avoidTime = 0.8 / wheel_v_speed *1.5
   
        print(turn90degreeTime)
        turnUntilTime1=sim.getSimulationTime()+turn90degreeTime  -- turn right
        turnUntilTime2 = turnUntilTime1 + avoidTime -- forward in right direction
        turnUntilTime3 = turnUntilTime2 + turn90degreeTime * 1.5 -- turn left
    end 
     if (turnUntilTime3<sim.getSimulationTime()) then
        -- When in forward mode, we simply move forward at the desired speed
        sim.setJointTargetVelocity(leftMotor,speed)
        sim.setJointTargetVelocity(rightMotor,speed)
    else if  (sim.getSimulationTime() <= turnUntilTime1) then -- turn right
            sim.setJointTargetVelocity(leftMotor,speed)
            sim.setJointTargetVelocity(rightMotor,0)
        else if (sim.getSimulationTime() <= turnUntilTime2) then -- forward in right direction
            sim.setJointTargetVelocity(leftMotor,speed)
            sim.setJointTargetVelocity(rightMotor,speed)
             else if (sim.getSimulationTime() <= turnUntilTime3) then -- turn left
            sim.setJointTargetVelocity(leftMotor,0)
            sim.setJointTargetVelocity(rightMotor,speed)
                  end
            end
        end
    end

    -- put your actuation code here
end

function sysCall_sensing()
local result,distData=sim.checkDistance(robotCollection,sim.handle_all)
	if result>0 then
		sim.addDrawingObjectItem(distanceSegment,nil)
		sim.addDrawingObjectItem(distanceSegment,distData)
		sim.setGraphStreamValue(graph,distStream,distData[7])
	end
	local p=sim.getObjectPosition(bubbleRobBase,-1)
	sim.addDrawingObjectItem(robotTrace,p)
    
end

function sysCall_cleanup()
    -- 清除绘图对象和图表流，释放资源
    sim.removeDrawingObject(distanceSegment)
    sim.removeDrawingObject(robotTrace)
    
    -- 清除图表中的数据流
    sim.removeGraphStream(graph, distStream)

    -- 打印一条信息，以便知道清理完成
    print("仿真结束，资源已清理")
end
将bubbleRob避障仿真里的控制脚本移植到Python远程控制方式。
移除原有的视觉传感器，浮动视窗，速度调节UI，Graph，以及绿色表示最小距离的线段，它们相关联的代码也一并移除。
保留机器人路径轨迹图。由于remote API中没有绘图的相关函数。因此该部分功能仍保留在bubbleRob脚本中。
仿真时间长度设置为60秒。
采用同步、阻塞模式的通信方式。
